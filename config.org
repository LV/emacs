#+TITLE: LV's Emacs Configuration
#+AUTHOR: Luis Victoria
#+PROPERTY: header-args :tangle yes

- The following =.org= file takes all the code blocks and tangles (i.e., compiles) them to =config.el=, from which =init.el= (the default entrypoint) reads off of.
  - This document will not have the best organization, and that's due to the constraint of needing to execute certain lines of code before others.

- Due to constraints with developing on remote machines, I am forced to use Neovim for development (I actually like it a lot, but no org-mode sadly)
  - Hence, I want to replicate as much of the behavior as possible between both configurations
  - [[https://github.com/LV/nvim-config][Link to my Neovim configuration]]
    - I may end up going for some weird dynamic where I use Neovim inside of Emacs that emulates a terminal (that uses ~tmux~). That sounds incredibly dumb (and it probably is), but I think that's what I may actually end up going for.

* Pre-requisites
You *must* do the following to get the configuration to fully work.

/NOTE/: If you're building this through my [[https://github.com/lv/nixos][NixOS Flake]], it'll take care of everything you need ðŸ™‚

** Programs
*** Dirvish
Dirvish is the file manager used for this configuration

**** ~fd~
***** MacOS
#+begin_src sh :tangle no
  brew install fd
#+end_src

**** ~ffmpegthumbnailer~
Video preview

***** MacOS
#+begin_src sh :tangle no
  brew install ffmpegthumbnailer
#+end_src
**** ~gls~
***** MacOS
#+begin_src sh :tangle no
  brew install g-ls
#+end_src

**** ~imagemagick~
**** ~mediainfo~
***** MacOS
#+begin_src sh :tangle no
  brew install --cask mediainfo
#+end_src

*** Latex
**** Linux
#+begin_src bash :tangle no
  sudo apt-get install texlive-base texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended dvipng
#+end_src

**** MacOS
#+begin_src bash :tangle no
  brew install --cask mactex-no-gui
#+end_src

*** ~ripgrep~
**** Debian
#+begin_src sh :tangle no
  sudo apt install ripgrep
#+end_src

*** ~sqlite3~
**** Debian
#+begin_src sh :tangle no
  sudo apt install sqlite3 libsqlite3-dev
#+end_src

*** VTerm
**** Debian
#+begin_src sh :tangle no
  sudo apt install cmake libtool libvterm-dev
#+end_src

**** MacOS
#+begin_src sh :tangle no
  brew install cmake
#+end_src

** LSPs
- Pyright
- clangd
** Fonts
- [[https://fsd.it/shop/fonts/pragmatapro/][PragmataPro Mono Liga]] (Not free)
  - Alternatively, any [[https://www.nerdfonts.com/][Nerd Font]] should work

Evaluate the following commands in Emacs:

#+begin_src emacs-lisp :tangle no
  (all-the-icons-install-fonts)
  (nerd-fonts-install-fonts)
#+end_src

** Troubleshooting
*** Windows
Don't use Windows (and if you do, use WSL).

*** Org-mode package not found
This might only happen on the first attempt. Close Emacs and launch it again.

*** ~package-refresh-contents~

If something breaks when installing new packages, chances are that you'll need to run:

#+begin_src emacs-lisp :tangle no
  M-x package-refresh-contents
#+end_src

**** Examples of errors that this will fix
- Package =compat= unavailable
- Package =foo= not found in MELPA

* Setting Up the Package Manager
Bring in the package management functions into the environment

#+begin_src emacs-lisp
  (require 'package)
#+end_src

Set up package URLs

#+begin_src emacs-lisp
  (setq package-archives '(("melpa" . "https://melpa.org/packages/")
                           ("elpa"  . "https://elpa.gnu.org/packages/")))
#+end_src

Initialize the package system and prepare it to be used

#+begin_src emacs-lisp
  (package-initialize)
#+end_src

Refresh contents only if packages don't exist

#+begin_src emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

Initialize ~use-package~ on non-Linux platforms

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  (setq use-package-always-ensure t)
#+end_src

* Editor
** Startup Message
Start Emacs with a blank buffer instead of the welcome message.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

** Line Numbers
*** Relative Line Numbers
Better for using Vim commands.

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
#+end_src

*** Enable Line Numbers
#+begin_src emacs-lisp
  (global-display-line-numbers-mode t)
#+end_src

*** Set Line Number Width
There is some annoying behavior where once you scroll to a line number with an extra digit, the entire code buffer will shift one character to the right to accomodate for this new line number digit.

Instead, we will set the size of this to be the maximum amount of digits necessary for our document, and then fix this in size.

#+begin_src emacs-lisp
  (setq display-line-numbers-width-start t)
#+end_src

**** Exceptions
For the terminal, line numbers add noise and it's better not to have them.

#+begin_src emacs-lisp
  (dolist (mode '(treemacs-mode-hook
                  vterm-mode-hook))
    (add-hook mode (lambda ()
                     (display-line-numbers-mode 0))))
#+end_src

*** Column Number Mode
Displays the horizontal char position.

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

** Text Wrapping
I hate scrolling horizontally.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'visual-line-mode)
#+end_src

** Font
We create a helper function to set our font. Note that in terminal mode, Emacs has no control over font rendering (including font sizes) as it's left to the terminal to do this.

#+begin_src emacs-lisp
  (defun lv/set-font (font-list height)
    "Set the first available font from FONT-LIST with HEIGHT"
    (when (display-graphic-p)
      (catch 'font-found
        (dolist (font font-list)
          (when (find-font (font-spec :name font))
            (set-face-attribute 'default nil :font font :height height)
            (throw 'font-found font)))
        (message "No font from the list is available!"))))
#+end_src

We choose the size and fonts depending on the system type.

#+begin_src emacs-lisp
  (cond
   ((eq system-type 'gnu/linux)
    (lv/set-font '("PragmataPro Mono Liga" "Hack" "DejaVu Sans Mono") 120))
   ((eq system-type 'darwin) ; MacOS
    (lv/set-font '("PragmataPro Mono Liga" "Hack" "DejaVu Sans Mono") 200)))
#+end_src

** Toolbar
*** Disabling the Menu Bar
The menu bar is what has the /File/, /Edit/, /Options/, /Help/, etc. options at the top of the window.

Because we do everything through keyboard commands in Emacs, this is unnecessary and thus we disable it.

#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** Disabling the Tool Bar
The tool bar is the section under the menu bar that displays icons such as /New File/, /Open Directory/, /Save/, /Undo/, /Cut/, etc.

I think this is unnecessary because, once again, we do everything via keybinds and commands.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** Disabling Tooltips
- Tooltips are small little popups that appear when you're hovering over an element; they generally display additional help information
  - Generally, I think using ~helpful~ is better
  - I prefer everything to live in a single window, and having multiple windows might not just be distracting, but problematic with certain display managers

#+begin_src emacs-lisp
  (tooltip-mode -1)
#+end_src

** Scrolling
*** Disable Scrollbar
- We already have line numbers for navigation, and commands to jump around the document more effectively
  - I don't find it particularly useful to know which section (as in you're 30% into the document) you're in

#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** Smooth Scrolling
By default, going up or down the buffer until the boundary will result in jumping to the next 10-15 lines.

I prefer smooth scrolling (one line at a time).

#+begin_src emacs-lisp
  (setq scroll-conservatively 101
        scroll-margin 0
        scroll-preserve-screen-position 't)
#+end_src

** Aesthetics
*** Theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :init (load-theme 'doom-molokai t))
#+end_src

*** Icons
Enable icons via specialized fonts

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

*NOTE*: When running this configuration for the first time, you will need to run the following

#+begin_src emacs-lisp :tangle no
  M-x all-the-icons-install-fonts
  M-x nerd-icons-install-fonts
#+end_src

*** Emojis
I think emojis in documents are a good thing (in moderation and appropriate cases)

ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚ðŸ˜‚

#+begin_src emacs-lisp
  (use-package emojify
    :hook (after-init . global-emojify-mode))
#+end_src

*** Padding
**** Line Spacing
Per buffer line spacing can be set using the variable ~line-spacing~. Something like ~0.1~ goes well here.

#+begin_src emacs-lisp
  (setq-default line-spacing 0.1)
#+end_src

**** Top Padding
Setting format to empty string ~" "~ gives you top padding. Changing the header line face height will change the spacing

#+begin_src emacs-lisp
  (setq header-line-format " ")
#+end_src

**** Side Padding
#+begin_src emacs-lisp
  (lambda ()
    (progn
      (setq left-margin-width 2)
      (setq right-margin-width 2)
      (set-window-buffer nil (current-buffer))))
#+end_src

**** Fringe Space
Add fringe space to the left and right of the buffer

#+begin_src emacs-lisp
  (set-fringe-mode 10)
#+end_src

*** Modeline
Modeline is thte bar in the bottom that gives you a general overview of the buffer you're in. It shows you:
- What Vim Mode you're in (e.g. insert, normal, visual, etc.)
- The path of the file you're editing with respect to the project directory
- What line and column number your cursor is at
- Text encoding (e.g. UTF-8)
- What git branch name you're on

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 15))
#+end_src

*** Rainbow Delimiters
- Especially when writing lisp, it can be very difficult to keep track of which ~(~ belongs to which ~)~
  - This package makes it easy to distinguish this

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Directory Buffer
- We use ~dirvish~ for our file/directory management
  - For documentation on customizing ~dirvish~, [[https://github.com/alexluigit/dirvish/blob/main/docs/CUSTOMIZING.org][see here]]

#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :config
    (dirvish-override-dired-mode) ; Force the use of dirvish instead of dired
    (setq dirvish-attributes
          '(vc-state subtree-state all-the-icons file-time file-size))
    (setq dired-auto-revert-buffer t))
#+end_src

** ~undo-tree~
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    ; (setq undo-tree-auto-save-history nil) ; Disable persistent history
    (global-undo-tree-mode 1))

  ; TODO: Make buffer width for calling undo-tree significantly thinner
#+end_src

** Global Keybindings and Vim
Setting this up at the top just in case

*** ~ESC~ Behaviors
Make ~ESC~ key quit prompts

#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)  ; Make ESC quit prompts
#+end_src

- We want the ~ESC~ key to be immediately responsive
  - On default terminal Emacs, when the ~ESC~ key is pressed, there is about a 700ms delay between switching from insert mode to normal mode
    - This could be attributed to using a slower terminal emulator. The delay was quite big on WezTerm, but using Alacritty I noticed that this delay was significantly reduced
      - I tried using Emacs on Kitty, and it was the slowest. I've found that Alacritty in general is the best performing emulator
      - My laptop is also quite bad, so these performance differences are important

#+begin_src emacs-lisp
  (setq evil-esc-delay 0)
#+end_src

This fixes the delay in WezTerm, although I'm not sure in the first place why the behavior is different across the two terminal emulators.

*** Evil Mode
Evil mode allows you to use Vim keybindings in all Emacs buffers. Vim keybindings are just better than Emacs keybindings

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    :custom
    (evil-undo-system 'undo-tree)
    :config
    (evil-mode 1) ; turn on Evil mode
    ; (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state) ; I think this is the same as just hitting escape when you're not in insert mode
    ; (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)

    (define-key evil-normal-state-map (kbd "/") 'swiper)
    (define-key evil-visual-state-map (kbd "/") 'swiper))
#+end_src

**** Evil Collection
A package that extends Vim keybindings to work with other packages such as =magit=, =org=, =mu4e=, etc.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil magit)
    :ensure t
    :config
    (evil-collection-init))
#+end_src

** Indentation
*** C++
- Spaces; 4 Spaces per Tab

#+begin_src emacs-lisp
  (setq auto-mode-alist
        (append
         '(("\\.cpp\\'" . c++-mode)
           ("\\.h\\'"   . c++-mode)
           ("\\.hpp\\'" . c++-mode)
           ("\\.cxx\\'" . c++-mode)
           ("\\.hxx\\'" . c++-mode)
           ("\\.cc\\'"  . c++-mode)
           ("\\.hh\\'"  . c++-mode))
         auto-mode-alist))

  ;; Set indentation settings for C++ mode
  (defun lv/c++-setup ()
    "Set up C++ indentation preferences."
    (setq c-basic-offset 4)  ;; Set indentation to 4 spaces
    (setq tab-width 4)       ;; Set tab width to 4
    (setq indent-tabs-mode nil))  ;; Use spaces instead of tabs

  (add-hook 'c++-mode-hook 'lv/c++-setup)
#+end_src

* Behaviors
** Remove Backup Files
Say that you're editing the file =foo.py=. Annoyingly, Emacs will create the file =foo.py~= as a backup file and will create =#foo.py#= if the file is currently being edited. We want to disable this.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
#+end_src

** Require Final Newline
Every file should have a newline at the very end

#+begin_src emacs-lisp
  (setq mode-require-final-newline t)
#+end_src

** Use ~y~ and ~n~ for Prompts
I don't like needing to type the entire word ~yes~ or ~no~ and then pressing ~RET~ when prompted on things like if I want to save a file or not.

It's much easier to just use ~y~ and ~n~.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Alert for invalid action
When performing an action that can't be done (e.g. backspacing on first character of document, down arrow on last line, etc.):
- If ~t~, visual cue will show
- If ~nil~, bell will sound
- Default behavior is ~nil~

/NOTE/: On MacOS, this makes a large caution triangle which can be very annoying, so perhaps disable if using Mac

#+begin_src emacs-lisp
  (cond
   ((eq system-type 'gnu/linux)
    (setq visible-bell t))
   ((eq system-type 'darwin) ; MacOS
    (setq visible-bell nil)))
#+end_src

* Modules
** Ivy
Ivy is a completion framework that allows you to find files, switch buffers, etc.

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :bind ((:map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-l" . ivy-done)
             ("C-d" . ivy-switch-buffer-kill))
           (:map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill)))
    :config
    (setq ivy-re-builders-alist
          '((t . ivy--regex-plus)))    ; Enable normal search globally
          ; '((t . ivy--regex-fuzzy))) ; Enable fuzzy search globally
                                       ; NOTE: These two options are mutually exclusive
    (ivy-mode 1))
#+end_src

*** Counsel
Counsel is an extension of Ivy and enhances features such as looking for commands, and makes use of Ivy's completion framework capabilities

#+begin_src emacs-lisp
    (use-package counsel
      :after ivy)
#+end_src

**** Ignoring Files in search
When searching for files using =M-x counsel-find-file=, you will get results for all existing files. Some files are incredibly annoying and I never have a need to find them. These are (listed with respect to the order on the regex expression):
- =.~undo-tree~=
  - Store file's undo-tree onto disk, used to load tree and undo across sessions
- =#foo#=
  - Emacs backup files
- =.DS_Store=
  - Used in MacOS to store custom attributes of the existing folder

Note that the syntax for regexes in Emacs is different than what you might be used to seeing in Perl.
- ~\\~ is used to begin a regex
- ~\\|~ is used to append regexes

[[https://regex101.com/][regex101]] is an excellent resource to build and test your regex strings.

#+begin_src emacs-lisp
  (setq counsel-find-file-ignore-regexp
        (concat "\\"
                ".~undo-tree~$\\|" ; .~undo-tree~
                ".*#.*#$"))        ; #foo#
#+end_src

** Helpful
Alternative help screen in Emacs that gives better information on possible values for variables and functions, as well as default values

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src

** SQLite3
This is depended by =magit=. Please install the necessary system modules beforehand (check Pre-requisites for more information)

#+begin_src emacs-lisp
  (use-package sqlite3
    :ensure t)
#+end_src

** Git
*** Magit
Magit is a porcerlain for Git that allows you to quickly stage, commit, pull, push, and do other basic Git commands with just a series of keybindings. It is a great way to quickly perform actions and not need to open a shell to perform Git commands.

#+begin_src emacs-lisp
  ;; Git porcelain
  (use-package magit
    :commands (magit-status magit-get-current-branch) ; lazy load
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

**** Tweaks
***** Insert Mode in Commit Message Prompts
When writing a commit mesasge, I want to be in /insert mode/ immediately

#+begin_src emacs-lisp
  (add-hook 'with-editor-mode-hook 'evil-insert-state)
#+end_src

***** Stop ~ediff~ from Creating New Window just for Help Commands
Very annoyingly, ~ediff~ will create a new window just for showing you help commands upon being invoked. This totally messes up my workflow especially if Emacs is full-screened.

We want to disable this.

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

***** Show ~ediff~ Diffs Vertically
The default behavior is that diffs are split horizontally (-). I prefer vertical splits (|) when viewing diffs as that's probably just what I've been used to with GitHub's UI.

I have no idea why, but the following will change the behavior to have vertical splits.

#+begin_src emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

***** Add Better Visibility to ~ediff~ Diffs
This will add a faint background to lines with merge-conflicting diffs

#+begin_src emacs-lisp
  (custom-set-faces
   '(ediff-current-diff-A ((t (:background "yellow" :foreground "black"))))
   '(ediff-current-diff-B ((t (:background "yellow" :foreground "black"))))
   '(ediff-fine-diff-A ((t (:background "orange" :foreground "black"))))
   '(ediff-fine-diff-B ((t (:background "orange" :foreground "black")))))
#+end_src

***** Refine Differences in ~ediff~
Narrow down the exact words or characters that differ

#+begin_src emacs-lisp
  (setq ediff-auto-refine 'on)
#+end_src

***** Use ~:w~ and ~:q~ to commit/abort
While I am used to doing =C-c C-c= to commit a message at this point, I want to do it the Vim way

#+begin_src emacs-lisp
  (defun lv/magit-commit-save-and-exit ()
    "Commit the message and close the buffer."
    (interactive)
    (with-editor-finish))

  (defun lv/magit-commit-abort ()
    "Abort the commit message and close the buffer."
    (interactive)
    (with-editor-cancel))

  (defun lv/setup-git-commit-mode-evil-commands ()
    "Set up buffer-local Evil ex commands in `git-commit-mode`."
    ;; Make `evil-ex-commands` buffer-local by copying it as a hash table
    (setq-local evil-ex-commands (copy-hash-table evil-ex-commands))
    ;; Define buffer-local ex commands
    (evil-ex-define-cmd "w[rite]" #'lv/magit-commit-save-and-exit) ; FIXME: Fix this, performing just ~:w~ doesn't commit and then quit buffer
    (evil-ex-define-cmd "wq"     #'lv/magit-commit-save-and-exit)
    (evil-ex-define-cmd "q[uit]" #'lv/magit-commit-abort))

  ;; Add the hook for `git-commit-mode`
  (add-hook 'git-commit-mode-hook #'lv/setup-git-commit-mode-evil-commands)
#+end_src

***** Change Text Color for Highlighted Added Diffs
- On Alacritty for some reason, added diffs (highlighted in green) are really hard to see with the default settings (green text on green background)
  - This behavior is different when using WezTerm
    - Regardless, I will change this for all non-grahical instances of Emacs

#+begin_src emacs-lisp
  (unless (display-graphic-p)
    (with-eval-after-load 'magit
      (set-face-attribute 'magit-diff-added nil
                          :foreground "#003000"
                          :background nil)
      (set-face-attribute 'magit-diff-added-highlight nil
                          :foreground "#003000"
                          :background nil)))
#+end_src

*** Forge
Forge is an extension of ~magit~ that adds support for interacting with Git forges such as GitHub, directly from Emacs.

You can view, comment, and create pull requests or issues directly from Emacs.

#+begin_src emacs-lisp
  (use-package forge)
#+end_src

*** TODO
- [ ] Make ~<escape>~ key abort (give it the same behavior as ~C-g~) in =magit=

** yasnippet
A templating system. Allows you to type ~>TEMPLATE~ and then press ~TAB~ to expand the template

#+begin_src emacs-lisp
  (use-package yasnippet
    :ensure t
    :config
    (yas-global-mode 1))
#+end_src

** Org-mode
#+begin_src emacs-lisp
  (use-package org
    :ensure nil)
#+end_src

*** Directory
I treat everything ~org~ like a monolith, and have it live in a single directory.

#+begin_src emacs-lisp
  (setq lv/org-directory "~/org")
#+end_src

*** Addons
**** Org-roam
Org-roam is an extension that makes it easy to create topic-focused org files and link them together using backlinks.

Org-roam treats information as a node in a network (like a brain) rather than a heirarchy like a traditional org document.

I use the Zettelkasten method. You can visit [[https://writing.bobdoto.computer/zettelkasten/][this page]] for notes on how this notetaking system works.

SQLite is a prerequisite, see /Pre-requisites/ at the top for instructions on how to install.

*NOTE*: Make sure the =~/org/roam= directory exists

#+begin_src emacs-lisp
  (use-package org-roam
    :ensure t
    :custom
    (org-roam-directory (concat lv/org-directory "/roam"))
    (org-roam-dailies-directory (concat lv/org-directory "/daily"))
    (org-roam-completion-everywhere t)
    :config
    (org-roam-setup))

  ; TODO: Add 2 newlines after a new daily entry
#+end_src

***** UI
We use ~org-roam-ui~ to be able to visualize our Zettelkasten.

~websocket~ is a prereq

#+begin_src emacs-lisp
  (use-package websocket
    :after org-roam)
#+end_src

And afterwards, we install ~org-roam-ui~

#+begin_src emacs-lisp
  (use-package org-roam-ui
    :after org-roam
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))
#+end_src

**** Mermaid Diagrams
#+begin_src emacs-lisp
  (use-package mermaid-mode
    :ensure t
    :mode "\\.mmd\\'"
    :config
    (setq mermaid-mmdc-location "mmdc"))
#+end_src

#+begin_src emacs-lisp
  (use-package ob-mermaid
    :ensure t
    :after org
    :config
    (setq ob-mermaid-cli-path "mmdc")  ;; Path to mmdc in Nix
    (org-babel-do-load-languages
     'org-babel-load-languages
     '((mermaid . t))))
#+end_src

Add =mermaid= to =orb-babel= languages

#+begin_src emacs-lisp
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((mermaid . t)))
#+end_src

**** Calendar
I use the ~calfw~ package to add a calendar to org-mode

#+begin_src emacs-lisp
  (use-package calfw
    :ensure t)

  (use-package calfw-org
    :ensure t
    :after (calfw org)
    :config
    (setq cfw:org-agenda-schedule-args '(:timestamp))
    (setq cfw:org-overwrite-default-keybinding t))
#+end_src

**** Agenda
We set the file for the agenda

#+begin_src emacs-lisp
  (setq lv/org-agenda-path (concat lv/org-directory "/agenda.org"))
#+end_src

#+begin_src emacs-lisp
  (setq org-agenda-files (list lv/org-agenda-path))

#+end_src

#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode))
#+end_src

*** Templates
**** ~org-capture~ Templates
***** Targets
#+begin_src emacs-lisp
  (defun lv/org-capture--fleeting-target ()
    "Return the path to the fleeting note file for today."
    (let ((fleeting-path (expand-file-name (format-time-string "%Y%m%d%H%M%S-%s.org") (concat lv/org-directory "/fleeting"))))
      (set-buffer (org-capture-target-buffer fleeting-path))
      (widen)
      (goto-char (point-max))))
#+end_src

***** Templates
#+begin_src emacs-lisp
  (setq org-capture-templates
        '(("a" "Appointment" entry
           (file+headline lv/org-agenda-path "Appointments")
           "* %?\n  %^T")

          ;; Zettelkasten
          ("f" "Fleeting Note" plain
           (function lv/org-capture--fleeting-target)
           "%?"
           :if-new (file+head "zk/fleeting/%<%Y%m%d%H%M%S>-${slug}.org"
                              "#+title: ${title}\n#+created: %U\n")
           :unnarrowed t)))
#+end_src

**** ~org-dailies~
I like having a timestamp for every new entry in my dailies
#+begin_src emacs-lisp
  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry "* [%<%H:%M:%S>] %?"
           :if-new (file+head "%<%Y-%m-%d>.org"
                              "#+title: %<%Y-%m-%d>\n#+author: Luis Victoria\n#+CREATED: %U\n\n"))))
#+end_src


**** Snippets Using ~yasnippet~
Create snippets by typing ~>TEMPLATE~

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook #'yas-minor-mode)
#+end_src

Open ~org-edit-special~ if generating a template with a code block

#+begin_src emacs-lisp
  (defun lv/org-edit-special-after-snippet ()
    "Call `org-edit-special` after a snippet expansion in Org mode."
    (when (org-in-src-block-p)
      (org-edit-special)))

  ;; Add this function to the yasnippet post expansion hook
  (add-hook 'yas-after-exit-snippet-hook 'lv/org-edit-special-after-snippet)
#+end_src

We want to return to normal mode (instead of insert mode) once we leave ~org-edit-special~

#+begin_src emacs-lisp
  (defun lv/exit-org-edit-special-normal-state ()
    "Force Evil to go to normal state after exiting `org-edit-special`."
    (when (org-in-src-block-p)
      (evil-normal-state)))

  ;; Advise `org-edit-src-exit` to ensure we're in normal state in Evil
  (advice-add 'org-edit-src-exit :after #'lv/exit-org-edit-special-normal-state)
#+end_src

*** Text
**** Show Leading Stars in Headers
I like seeing all the stars so I know which indentation level we're at.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (setq-local org-hide-leading-stars nil)))
#+end_src

**** Show Links
Modifying links in org-mode has been a real pain due to its default behavior of hiding the link. I want everything to show up.

#+begin_src emacs-lisp
  (setq org-descriptive-links nil)
#+end_src

**** Bullet Points
Replace the ~-~ symbol with ~â€¢~.

#+begin_src emacs-lisp
  (font-lock-add-keywords 'org-mode
                          '(("^ *\\([-]\\) "
                             (0 (prog1 () (compose-region (match-beginning 1) (match-end 1) "â€¢"))))))
#+end_src

**** Automatically Render $LaTeX$ Fragments
We first need to check if $LaTeX$ packages are installed. We want to be robust and make this optional as these packages can get quite large.

#+begin_src emacs-lisp
  (defun lv/latex-packages-installed-p ()
    "Check if necessary LaTeX packages are installed."
    (executable-find "latex"))
#+end_src

Run the auto-rendering if the package is found

#+begin_src emacs-lisp
  (when (and (lv/latex-packages-installed-p)
             (display-graphic-p))
    (defun lv/org-latex-preview-auto ()
      "Automatically refresh LaTeX fragments in the current buffer."
      (when (derived-mode-p 'org-mode)
        (org-latex-preview '(16))))

    ;; Add hooks to automatically render LaTeX
    (add-hook 'org-mode-hook 'lv/org-latex-preview-auto)
    (add-hook 'after-save-hook 'lv/org-latex-preview-auto)
    (add-hook 'after-change-functions
              (lambda (_beg _end _len)
                (lv/org-latex-preview-auto)))

    ;; Scale LaTeX font
    (setq org-format-latex-options (plist-put org-format-latex-options :scale 1.5)))
#+end_src

**** Render Entire Document Before Editing
There's a bug where if you jump to any part of a document, code blocks will not be rendered until both its ~#+begin_src~ and ~#+end_src~ tags are encountered.

By rendering the entire document, code blocks will appear as they should, new code blocks will not have this problem since as you write them, you will 'encounter' it.

#+begin_src emacs-lisp
  (defun lv-org-render-before-editing () "Render whole Org buffer before editing"
    (read-only-mode 1)   ; Make the buffer temporarily read-only
    (font-lock-ensure)   ; Ensure the whole buffer is rendered
    (read-only-mode -1)) ; Allow editing again

  (add-hook 'org-mode-hook 'lv-org-render-before-editing)
#+end_src

*** Evil (Vim)
**** Code Blocks (Edit Special)
When editing source code blocks in org-mode, you will encounter many difficulties in getting the indentation right. This is due to the conflicts of org-mode's indentation with the one you're trying to do for your code (minor mode).

When you're in major mode (i.e., normal code editing in its own buffer), you will not experience these issues.

Thus, the best way to edit such code is through ~(org-edit-special)~ (which can be invoked using ={SPC o e}=). This will open the code block in its own buffer and you'll be able to have the full normal coding experience you're used to.

However, the saving (={C-c '}=) and aborting (={C-c C-k}=) commands are ugly Emacs bindings, and we want to do it the Vim way through ~:w~, ~:wq~, or ~:q~ (~:q!~ works too).

#+begin_src emacs-lisp
  (defun lv/org-edit-src-save-only ()
    "Save changes in the special edit buffer without exiting."
    (interactive)
    (org-edit-src-save))

  (defun lv/org-edit-src-exit-save ()
    "Save changes and exit the special edit buffer."
    (interactive)
    (org-edit-src-exit))

  (defun lv/org-edit-src-abort ()
    "Abort the special edit without saving."
    (interactive)
    (org-edit-src-abort))

  (defun lv/setup-org-src-mode-evil-commands ()
    "Set up custom `:w`, `:wq`, and `:q` commands in `org-src-mode`."
    (evil-ex-define-cmd "w[rite]" 'lv/org-edit-src-save-only)
    (evil-ex-define-cmd "wq" 'lv/org-edit-src-exit-save)
    (evil-ex-define-cmd "q[uit]" 'lv/org-edit-src-abort))

  (defun lv/restore-evil-commands ()
    "Restore default `:w`, `:wq`, and `:q` Evil commands."
    (evil-ex-define-cmd "w[rite]" 'evil-write)
    (evil-ex-define-cmd "wq" 'evil-save-and-close)
    (evil-ex-define-cmd "q[uit]" 'evil-quit))

  (defun lv/setup-org-src-mode-hook ()
    "Hook to set up `org-src-mode`."
    ;; Set up custom commands for the current buffer only
    (lv/setup-org-src-mode-evil-commands)
    ;; Set up a buffer-local hook to restore commands on exit
    (add-hook 'kill-buffer-hook 'lv/restore-evil-commands nil t))

  ;; Add hook to org-src-mode to set up the custom commands
  (add-hook 'org-src-mode-hook 'lv/setup-org-src-mode-hook)
#+end_src

**** Header Indentation
When pressing ~>~ or ~<~ in Vim, it changes the indentation of your text. However, when on an org-mode header, I'd like this to change the asterisks on the header and not the actual indentation of the header.

I want this feature to be only available if the cursor is on a header line. If I'm modifying some text and want to change the indentation of bullet points for instance, I would not want indenation to change the header above my text.

#+begin_src emacs-lisp
  (use-package org
    :config
    (with-eval-after-load 'evil
      (defun lv/org-header-p ()
        "Check if the current line is an Org header."
        (save-excursion
          (beginning-of-line)
          (looking-at-p org-outline-regexp)))

      (defun lv/org-demote-or-indent ()
        "Demote Org header if on header, otherwise indent region or insert tab."
        (interactive)
        (if (lv/org-header-p)
            (org-demote-subtree)
          (evil-shift-right-line 1)))

      (defun lv/org-promote-or-outdent ()
        "Promote Org header if on header, otherwise outdent region or insert tab."
        (interactive)
        (if (lv/org-header-p)
            (org-promote-subtree)
          (evil-shift-left-line 1)))

      ;; Remap > and < to promote/demote header level in org-mode when on a header
      (evil-define-key 'normal org-mode-map
        (kbd ">") 'lv/org-demote-or-indent
        (kbd "<") 'lv/org-promote-or-outdent)))
#+end_src

**** Automatically be in Insert Mode in New Entry
Upon invoking ~org-roam-dailies-capture-today~, you will get a new buffer but you will be in normal mode. It makes much more sense to be directly in insert mode.

#+begin_src emacs-lisp
  (advice-add 'org-roam-dailies-capture-today :after (lambda (&rest _) (evil-insert-state)))
#+end_src

*** Other Tweaks
#+begin_src emacs-lisp
  (setq org-startup-indented t
        org-ellipsis " ï„‡ " ; folding symbol
        org-pretty-entities t
        org-hide-emphasis-markers nil
        org-agenda-block-separator ""
        org-fontify-whole-heading-line t
        org-fontify-done-headline t
        org-fontify-quote-and-verse-blocks t)
#+end_src

**** Disable ~hl-line-mode~
Disables highlighting the line where the cursor is currently on.

#+begin_src emacs-lisp
  (add-hook 'org-mode-hook
            (lambda ()
              (hl-line-mode -1)))
#+end_src

**** TODO Potential Additional features
- [[https://github.com/l3kn/org-fc][org-fc]] for spaced repetition (or flashcards)
- [[https://ditaa.sourceforge.net/][ditaa]] and/or [[https://www.graphviz.org/][graphviz]] for inserting diagrams to org-mode
  - See [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-ditaa.html][org ditaa]] and [[https://orgmode.org/worg/org-contrib/babel/languages/ob-doc-dot.html][org dot]] respectively
- [[https://github.com/alphapapa/org-ql][org-ql]] for searching org-files

**** TODO Make ~<enter>~ be unindented when coming out of a bullet point
You already have =M-RET= creating indented bullet points, no need to have a newline be indented

** Projectile
Projectile is a way of organizing your projects

I want my projects inside of =~/Dev=. By default, it takes a very long time for the projects to show up in ~projectile-switch-project~, so we create a helper function to invoke the search of these folders. I tried adding them straight under ~:config~ and it still wasn't working.

#+begin_src emacs-lisp
  (defun lv/projectile-discover-projects()
    "Discover all projects in the search path"
    (interactive)
    (projectile-discover-projects-in-search-path))
#+end_src

#+begin_src emacs-lisp
  (use-package projectile
    :diminish projectile-mode
    :init
    (when (file-directory-p "~/Dev/")
      (setq projectile-project-search-path '("~/Dev/")))
    (setq projectile-switch-project-action #'projectile-dired)
    :config
    (setq projectile-enable-caching t)
    (projectile-mode 1)
    :bind-keymap
    ("C-c p" . projectile-command-map)
    :hook (projectile-mode . lv/projectile-discover-projects))
#+end_src

** Ripgrep
Despite =counsel-rg= using the ripgrep package in your system, =projectile-ripgrep= annoyingly requires the =ripgrep= Emacs package and will fail otherwise. Thus we need two copies of ripgrep ðŸ™„

#+begin_src emacs-lisp
  (use-package ripgrep
    :ensure t)
#+end_src

** Swiper
Swiper is used to search within the current buffer

With the default behavior, pressing =n= goes to the previous word whereas =C-n= goes to the next word. In Vim, it's =n= to go next and =Shift n= to go before

#+begin_src emacs-lisp
  (use-package swiper
    :after ivy
    :config
    ;; Rebind Evil keys for navigating matches after Swiper
    (evil-define-key 'normal 'global
      (kbd "n") 'isearch-repeat-forward
      (kbd "N") 'isearch-repeat-backward))
#+end_src

** vterm
Allows you to emulate the terminal in Emacs

#+begin_src emacs-lisp
  (use-package vterm
    :ensure t)
#+end_src

And I like having Emacs startup with the terminal

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook 'vterm)
#+end_src

The default behavior of ~vterm~ is to start in insert mode. Let's change it to normal mode.

*NOTE*: Without this ~0.1~ second delay, this command will not work; you might need to change this depending on how long ~vterm~ takes to launch, I have no idea if this fixes for every machine or just mine.

#+begin_src emacs-lisp
  (defun lv/switch-to-normal-after-vterm-delay ()
    "Switch to normal mode after vterm starts with a small delay."
    (run-at-time "0.1 sec" nil 'evil-normal-state))

  ;; Add this hook to switch to normal mode after vterm starts
  (add-hook 'vterm-mode-hook 'lv/switch-to-normal-after-vterm-delay)
#+end_src

*** Troubleshooting
**** Can't find ~vterm~ module
This happened to me on my MacOS. Something about launching the GUI doesn't give Emacs the ~$PATH~ variable with the homebrew path, and thus fails to find ~cmake~.

To fix this, simply launch Emacs on the terminal (you only have to do this once).

#+begin_src sh :tangle no
  emacs -nw
#+end_src

** ~hl-todo~
Highlight TODOs, FIXMEs, NOTEs, etc.

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FFFF00")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#00FFFF")
            ("NOTE"   . "#50C878")
            ("GOTCHA" . "#A020F0")
            ("HACK"   . "#FFA500")
            ("STUB"   . "#7393B3"))))
#+end_src

** ~which-key~
which-key shows which keybindings to press to invoke a command if such a keybinding exists

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3)) ; seconds
#+end_src

* LSP
Main documentation can be found [[https://emacs-lsp.github.io/lsp-mode/][here]].

** Add-ons
*** Header Breadcrumb
We add a breadcrumb to show the relative path of our current buffer in regards to the rest of the project

#+begin_src emacs-lisp
  (defun lv/lsp-setup-mode ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (setq lsp-headerline-breadcrumb-enable t)
    (setq lsp-headerline-breadcrumb-icons-enable t))

  ; TODO: Fix the missing icons in this breadcrumb header
#+end_src

** Installation
Install and use ~lsp-mode~

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode . lv/lsp-setup-mode)
           (c++-mode . lsp-deferred)
           (c-mode   . lsp-deferred))
    :init
    (setq lsp-keymap-prefix "C-c l")
    :config
    (lsp-enable-which-key-integration t))
#+end_src

** Extra Packages
*** Debugger
#+begin_src emacs-lisp
  (use-package dap-mode)
  ;; (use-package dap-LANGUAGE) to load the dap adapter for your language
#+end_src

*** ~which-key~ Integration
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

*** ~flycheck~
Performs real-time syntax checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))
#+end_src

*** ~lsp-treemacs~
#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :after (lsp-mode treemacs)
    :commands lsp-treemacs-errors-list) ; only load when this command is called
#+end_src

** Languages
*** Nix (Nil)
[[https://emacs-lsp.github.io/lsp-mode/page/lsp-nix-nil/][lsp-mode Nix Nil documentation]]

- I almost exclusively edit Nix packages when I'm using NixOS`
  - The package is called /nil/ on nixpkgs ([[https://search.nixos.org/packages?channel=24.05&show=nil&from=0&size=50&sort=relevance&type=packages&query=nil][(link)]])

#+begin_src emacs-lisp
  (use-package lsp-nix
    :ensure lsp-mode
    :after (lsp-mode)
    :demand t
    :custom
    (lsp-nix-nil-formatter ["nixfmt"]))

  (use-package nix-mode
    :hook (nix-mode . lsp-deferred)
    :ensure t)
#+end_src

*** Python (Pyright)
[[https://emacs-lsp.github.io/lsp-pyright/][lsp-mode Pyright documentation]]

Firstly, you will need to install ~basedpyright~ (and ~ruff~ for some reason) manually

#+begin_src sh :tangle no
  pip install basedpyright
  pip install ruff
#+end_src

And then we can install and use ~lsp-pyright~

#+begin_src emacs-lisp
  (use-package lsp-pyright
    :ensure t
    :custom (lsp-pyright-langserver-command "basedpyright")
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (lsp-deferred))))
#+end_src

** Company Mode
- Before, we'd need to invoke ~M-x completion-at-point~ everytime to get the buffer of autocompletable things
  - We get this automatically with ~company-mode~

- I like autocompleting by pressing ~TAB~ (the default behavior is pressing ~ENTER~)
  - Even if you rebind this to ~TAB~, the default behavior remains
    - I've binding ~ENTER~ to ~newline~ to fix this

- ~TAB~ key in GUI != ~TAB~ key in Terminal Emacs
  - In GUI, ~TAB~ is ~<tab>~
  - In Terminal mode, ~TAB~ is ~C-i~

#+begin_src emacs-lisp
  (use-package company
    :after lsp-mode
    :hook (prog-mode . company-mode)
    :bind
    (:map company-active-map
          ("<tab>"    . company-complete-selection)
          ("C-i"      . company-complete-selection)
          ("<return>" . newline))
    (:map lsp-mode-map
          ("<tab>"    . company-indent-or-complete-common)
          ("C-i"      . company-indent-or-complete-common)
          ("<return>" . newline))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)) ; seconds
#+end_src

#+begin_src emacs-lisp
  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

** LSP UI
Additional UI integrations.

See the [[https://github.com/emacs-lsp/lsp-ui][GitHub repo]] for more info.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode))
#+end_src

** Ivy

#+begin_src emacs-lisp
  (use-package lsp-ivy
    :commands lsp-ivy-workspace-symbol)
#+end_src

* Keybindings
** Leader Key
I like to use keybindings by pressing a leader key, which I map as the spacebar.

#+begin_src emacs-lisp
  ;; Setup keybindings with a leader key
  (use-package general
    :config
    (general-evil-setup t)

    (general-create-definer lv/leader-keys
      :states '(normal visual)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC"))
#+end_src

** =M-x=
The Meta key (=M-x=) is used to evaluate commands.

#+begin_src emacs-lisp
  (lv/leader-keys
    ":" '(counsel-M-x :which-key "M-x"))
#+end_src

** Buffer
#+begin_src emacs-lisp
  (lv/leader-keys
    "b"  '(:ignore b              :which-key "buffer")
    "bb" '(counsel-switch-buffer  :which-key "switch")
    "bk" '(kill-buffer-and-window :which-key "kill")
    "bt" '(tab-bar-new-tab        :which-key "new tab"))
#+end_src

** Code
When I open ~flymake-show-buffer-diagnostics~, I want the cursor to move to the new buffer. Otherwise, I need to move the cursor to this new buffer and then press ~q~ to close it.

#+begin_src emacs-lisp
  (defun lv/flymake-show-buffer-diagnostics-and-focus ()
    (interactive)
    (flymake-show-buffer-diagnostics)
    (other-window 1))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "c"   '(:ignore c                                    :which-key "code")
    "cd"  '(lsp-find-declarations                        :which-key "declaration")
    "cD"  '(lsp-find-definition                          :which-key "definition")
    "cf"  '(lsp-format-buffer                            :which-key "format")
    "cg"  '(lv/flymake-show-buffer-diagnostics-and-focus :which-key "diagnostics")
    "ci"  '(lsp-find-implementation                      :which-key "implementation")
    "cr"  '(lsp-find-references                          :which-key "references")
    "ct"  '(:ignore ct                                   :which-key "treemacs")
    "ctr" '(lsp-treemacs-references                      :which-key "references")
    "cts" '(lsp-treemacs-symbols                         :which-key "symbols")
    "ctt" '(treemacs                                     :which-key "tree")
    "cT"  '(lsp-find-type-definition                     :which-key "type definition"))

  ; TODO: Make buffers smaller for references, definitions, etc. Don't let it take 50% of the screen.
#+end_src

** Evaluate
#+begin_src emacs-lisp
  (lv/leader-keys
    "e"  '(:ignore e       :which-key "evaulate")
    "eb" '(eval-buffer     :which-key "buffer")
    "ee" '(eval-expression :which-key "expression"))
#+end_src

** File
I want a keybinding dedicated exclusively to opening ~config.org~

#+begin_src emacs-lisp
  (defun lv/open-config-file ()
    (interactive)
    (find-file (concat user-emacs-directory "config.org")))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "f"  '(:ignore f           :which-key "file")
    "ff" '(counsel-find-file   :which-key "find")
    "fc" '(lv/open-config-file :which-key "open config")
    "fg" '(counsel-rg          :which-key "ripgrep"))
#+end_src

** Git
#+begin_src emacs-lisp
  (lv/leader-keys
    "g"  '(:ignore g    :which-key "git")
    "gg" '(magit-status :which-key "status"))
#+end_src

** Help
#+begin_src emacs-lisp
  (lv/leader-keys
    "h"  '(:ignore h                 :which-key "help")
    "hf" '(counsel-describe-function :which-key "function")
    "hk" '(describe-key              :which-key "key")
    "hv" '(counsel-describe-variable :which-key "variable"))
#+end_src

** Org-mode
We have templates that we have defined in ~org-capture~. While we could just invoke ~org-capture~, we also have other documents that are not generated through this function. To have all possible generatable documents under one keystroke, we create a helper function to invoke the templates inside of ~org-capture~

#+begin_src emacs-lisp
  (defun lv/capture-appointment-note ()
    "Capture an appointment note."
    (interactive)
    (org-capture nil "a"))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "o"   '(:ignore o                      :which-key "org")
    "oa"  '(lv/capture-appointment-note    :which-key "appointment")
    "oc"  '(cfw:open-org-calendar          :which-key "calendar")
    "od"  '(:ignore od                     :which-key "daily")
    "ode" '(org-roam-dailies-capture-today :which-key "new entry")
    "odt" '(org-roam-dailies-goto-today    :which-key "view today's entries")
    "oe"  '(org-edit-special               :which-key "edit special")
    "oi"  '(:ignore oi                     :which-key "insert")
    "oii" '(org-id-get-create              :which-key "id")
    "oit" '(org-insert-structure-template  :which-key "template")
    "or"  '(:ignore or                     :which-key "roam")
    "ora" '(org-roam-alias-add             :which-key "add alias")
    "orf" '(org-roam-node-find             :which-key "find node")
    "ori" '(org-roam-node-insert           :which-key "insert node")
    "oru" '(org-roam-ui-mode               :which-key "UI")
    "ot"  '(:ignore ot                     :which-key "toggle")
    "oti" '(org-toggle-inline-images       :which-key "image")
    "otr" '(org-roam-buffer-toggle         :which-key "roam buffer")
    "ox"  '(org-ctrl-c-ctrl-c              :which-key "execute"))
#+end_src

** Projectile
#+begin_src emacs-lisp
  (lv/leader-keys
    "p"  '(:ignore p                    :which-key "project")
    "pa" '(projectile-add-known-project :which-key "add")
    "pg" '(projectile-ripgrep           :which-key "ripgrep") ; TODO: Make it so that once you perform a search, the cursor automatically moves to this buffer
    "pp" '(projectile-switch-project    :which-key "switch"))
#+end_src

** Terminal
#+begin_src emacs-lisp
  (lv/leader-keys
    "t" '(vterm :which-key "terminal"))
#+end_src

** Undo-tree
#+begin_src emacs-lisp
  (lv/leader-keys
    "u" '(undo-tree-visualize :which-key "undo tree"))
#+end_src

** Window
The following is a helper function for toggling full screen on and off

As per [[https://emacs.stackexchange.com/a/9725][Stack Exchange]]:

#+begin_src emacs-lisp
  (defun lv/fullscreen ()
    (interactive)
    (set-frame-parameter nil 'fullscreen 'fullboth))

  (defun lv/non-fullscreen ()
    (interactive)
    (set-frame-parameter nil 'width 82)
    (set-frame-parameter nil 'fullscreen 'fullheight))

  (defun toggle-fullscreen ()
    (interactive)
    (if (eq (frame-parameter nil 'fullscreen) 'fullboth)  ;tests if already fullscreened
        (lv/non-fullscreen)
      (lv/fullscreen)))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "w"  '(:ignore w          :which-key "window")
    "wf" '(toggle-fullscreen  :which-key "toggle fullscreen")
    "wh" '(evil-window-left   :which-key "move left")
    "wj" '(evil-window-down   :which-key "move down")
    "wk" '(evil-window-up     :which-key "move up")
    "wl" '(evil-window-right  :which-key "move right")
    "ws" '(evil-window-split  :which-key "split horizontally")
    "wv" '(evil-window-vsplit :which-key "split vertically"))
#+end_src

* TODO Future Features to add
- [ ] Add Spotify control panel
  - Perhaps integrate emacs with some sort of [[https://github.com/Spotifyd/spotifyd][Spotify daemon]]
- Maybe add workspaces (on top of tabs)
