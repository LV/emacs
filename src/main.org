#+TITLE: LV's Emacs Configuration
#+AUTHOR: Luis Victoria
#+PROPERTY: header-args :tangle yes

- The following =.org= file takes all the code blocks and tangles (i.e., compiles) them to =config.el=, from which =init.el= (the default entrypoint) reads off of.
  - This document will not have the best organization, and that's due to the constraint of needing to execute certain lines of code before others.

- Due to constraints with developing on remote machines, I am forced to use Neovim for development (I actually like it a lot, but no org-mode sadly)
  - Hence, I want to replicate as much of the behavior as possible between both configurations
  - [[https://github.com/LV/nvim-config][Link to my Neovim configuration]]
    - I may end up going for some weird dynamic where I use Neovim inside of Emacs that emulates a terminal (that uses ~tmux~). That sounds incredibly dumb (and it probably is), but I think that's what I may actually end up going for.

* Pre-requisites
You *must* do the following to get the configuration to fully work.

/NOTE/: If you're building this through my [[https://github.com/lv/nixos][NixOS Flake]], it'll take care of everything you need ðŸ™‚

** Programs
*** Dirvish
Dirvish is the file manager used for this configuration

**** ~fd~
***** MacOS
#+begin_src sh :tangle no
  brew install fd
#+end_src

**** ~ffmpegthumbnailer~
Video preview

***** MacOS
#+begin_src sh :tangle no
  brew install ffmpegthumbnailer
#+end_src

**** ~gls~
***** MacOS
#+begin_src sh :tangle no
  brew install g-ls
#+end_src

**** ~mediainfo~
***** MacOS
#+begin_src sh :tangle no
  brew install --cask mediainfo
#+end_src

*** Latex
**** Linux
#+begin_src bash :tangle no
  sudo apt-get install texlive-base texlive-latex-recommended texlive-latex-extra texlive-fonts-recommended dvipng
#+end_src

**** MacOS
#+begin_src bash :tangle no
  brew install --cask mactex-no-gui
#+end_src

*** ~ripgrep~
**** Debian
#+begin_src sh :tangle no
  sudo apt install ripgrep
#+end_src

*** ~sqlite3~
**** Debian
#+begin_src sh :tangle no
  sudo apt install sqlite3 libsqlite3-dev
#+end_src

** LSPs
- clangd
- Pyright
- YAML
** Fonts
- [[https://fsd.it/shop/fonts/pragmatapro/][PragmataPro Mono Liga]] (Not free)
  - Alternatively, any [[https://www.nerdfonts.com/][Nerd Font]] should work

Evaluate the following commands in Emacs:

#+begin_src emacs-lisp :tangle no
  (all-the-icons-install-fonts)
  (nerd-fonts-install-fonts)
#+end_src

** Troubleshooting
*** Windows
Don't use Windows (and if you do, use WSL).

*** Org-mode package not found
This might only happen on the first attempt. Close Emacs and launch it again.

*** ~package-refresh-contents~

If something breaks when installing new packages, chances are that you'll need to run:

#+begin_src emacs-lisp :tangle no
  M-x package-refresh-contents
#+end_src

**** Examples of errors that this will fix
- Package =compat= unavailable
- Package =foo= not found in MELPA

* Setting Up the Package Manager
Bring in the package management functions into the environment

#+begin_src emacs-lisp
  (require 'package)
#+end_src

Set up package URLs

#+begin_src emacs-lisp
  (setq package-archives '(("melpa"  . "https://melpa.org/packages/")
                           ("nongnu" . "https://elpa.nongnu.org/nongnu/")
                           ("gnu"    . "https://elpa.gnu.org/packages/")
                           ("elpa"   . "https://elpa.gnu.org/packages/")))
#+end_src

Initialize the package system and prepare it to be used

#+begin_src emacs-lisp
  (package-initialize)
#+end_src

Refresh contents only if packages don't exist

#+begin_src emacs-lisp
  (unless package-archive-contents
    (package-refresh-contents))
#+end_src

Initialize ~use-package~ on non-Linux platforms

#+begin_src emacs-lisp
  (unless (package-installed-p 'use-package)
    (package-install 'use-package))

  (require 'use-package)

  (setq use-package-always-ensure t)
#+end_src

* Editor
** Startup Message
Start Emacs with a blank buffer instead of the welcome message.

#+begin_src emacs-lisp
  (setq inhibit-startup-message t)
#+end_src

** Line Numbers
*** Relative Line Numbers
Better for using Vim commands.

#+begin_src emacs-lisp
  (setq display-line-numbers-type 'relative)
#+end_src

*** Enable Line Numbers
#+begin_src emacs-lisp
  (global-display-line-numbers-mode t)
#+end_src

*** Set Line Number Width
There is some annoying behavior where once you scroll to a line number with an extra digit, the entire code buffer will shift one character to the right to accomodate for this new line number digit.

Instead, we will set the size of this to be the maximum amount of digits necessary for our document, and then fix this in size.

#+begin_src emacs-lisp
  (setq display-line-numbers-width-start t)

  ;; FIXME: This is not working; saw a bug when editing a =.org= file
  ;;          weirdly, this doesn't happen to this config
#+end_src

**** Exceptions
For the terminal, line numbers add noise and it's better not to have them.

#+begin_src emacs-lisp
  (dolist (mode '(treemacs-mode-hook))
    (add-hook mode (lambda ()
                     (display-line-numbers-mode 0))))
#+end_src

*** Column Number Mode
Displays the horizontal char position.

#+begin_src emacs-lisp
  (setq column-number-mode t)
#+end_src

** Clipboard
While normal Emacs takes care of copy and pasting, I've had some issues copying to clipboard in terminal Emacs using Alacritty in WSL2 Ubuntu 22.02

The fix is to use ~clipetty~

#+begin_src emacs-lisp
  (use-package clipetty
    :ensure t
    :hook (after-init . global-clipetty-mode))
#+end_src

** Text Wrapping
I hate scrolling horizontally.

#+begin_src emacs-lisp
  (add-hook 'text-mode-hook 'visual-line-mode)
#+end_src

** Font
We create a helper function to set our font. Note that in terminal mode, Emacs has no control over font rendering (including font sizes) as it's left to the terminal to do this.

#+begin_src emacs-lisp
  (defun lv/set-font (font-list height)
    "Set the first available font from FONT-LIST with HEIGHT"
    (when (display-graphic-p)
      (catch 'font-found
        (dolist (font font-list)
          (when (find-font (font-spec :name font))
            (set-face-attribute 'default nil :font font :height height)
            (throw 'font-found font)))
        (message "No font from the list is available!"))))
#+end_src

We choose the size and fonts depending on the system type.

#+begin_src emacs-lisp
  (cond
   ((eq system-type 'gnu/linux)
    (lv/set-font '("PragmataPro Mono Liga" "Hack" "DejaVu Sans Mono") 120))
   ((eq system-type 'darwin) ; MacOS
    (lv/set-font '("PragmataPro Mono Liga" "Hack" "DejaVu Sans Mono") 200)))
#+end_src

** Toolbar
*** Disabling the Menu Bar
The menu bar is what has the /File/, /Edit/, /Options/, /Help/, etc. options at the top of the window.

Because we do everything through keyboard commands in Emacs, this is unnecessary and thus we disable it.

#+begin_src emacs-lisp
  (menu-bar-mode -1)
#+end_src

*** Disabling the Tool Bar
The tool bar is the section under the menu bar that displays icons such as /New File/, /Open Directory/, /Save/, /Undo/, /Cut/, etc.

I think this is unnecessary because, once again, we do everything via keybinds and commands.

#+begin_src emacs-lisp
  (tool-bar-mode -1)
#+end_src

*** Disabling Tooltips
- Tooltips are small little popups that appear when you're hovering over an element; they generally display additional help information
  - Generally, I think using ~helpful~ is better
  - I prefer everything to live in a single window, and having multiple windows might not just be distracting, but problematic with certain display managers

#+begin_src emacs-lisp
  (tooltip-mode -1)
#+end_src

** Scrolling
*** Disable Scrollbar
- We already have line numbers for navigation, and commands to jump around the document more effectively
  - I don't find it particularly useful to know which section (as in you're 30% into the document) you're in

#+begin_src emacs-lisp
  (scroll-bar-mode -1)
#+end_src

*** Smooth Scrolling
By default, going up or down the buffer until the boundary will result in jumping to the next 10-15 lines.

I prefer smooth scrolling (one line at a time).

#+begin_src emacs-lisp
  (setq scroll-conservatively 101
        scroll-margin 0
        scroll-preserve-screen-position 't)
#+end_src

** Aesthetics
*** Theme
#+begin_src emacs-lisp
  (use-package doom-themes
    :init (load-theme 'doom-bluloco-dark t))

  ; TODO: Make the color for the background of text selection more clear
  ; Currently very difficult to see which selection you're on
#+end_src

*** Icons
Enable icons via specialized fonts

#+begin_src emacs-lisp
  (use-package all-the-icons)
#+end_src

*NOTE*: When running this configuration for the first time, you will need to run the following

#+begin_src emacs-lisp :tangle no
  M-x all-the-icons-install-fonts
  M-x nerd-icons-install-fonts
#+end_src

*** Padding
**** Line Spacing
Per buffer line spacing can be set using the variable ~line-spacing~. Something like ~0.1~ goes well here.

#+begin_src emacs-lisp
  (setq-default line-spacing 0.1)
#+end_src

**** Top Padding
Setting format to empty string ~" "~ gives you top padding. Changing the header line face height will change the spacing

#+begin_src emacs-lisp
  (setq header-line-format " ")
#+end_src

**** Side Padding
#+begin_src emacs-lisp
  (lambda ()
    (progn
      (setq left-margin-width 2)
      (setq right-margin-width 2)
      (set-window-buffer nil (current-buffer))))
#+end_src

**** Fringe Space
Add fringe space to the left and right of the buffer

#+begin_src emacs-lisp
  (set-fringe-mode 10)
#+end_src

*** Modeline
Modeline is thte bar in the bottom that gives you a general overview of the buffer you're in. It shows you:
- What Vim Mode you're in (e.g. insert, normal, visual, etc.)
- The path of the file you're editing with respect to the project directory
- What line and column number your cursor is at
- Text encoding (e.g. UTF-8)
- What git branch name you're on

#+begin_src emacs-lisp
  (use-package doom-modeline
    :ensure t
    :init (doom-modeline-mode 1)
    :custom (doom-modeline-height 15))
#+end_src

*** Rainbow Delimiters
- Especially when writing lisp, it can be very difficult to keep track of which ~(~ belongs to which ~)~
  - This package makes it easy to distinguish this

#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

** Directory Buffer
- We use ~dirvish~ for our file/directory management
  - For documentation on customizing ~dirvish~, [[https://github.com/alexluigit/dirvish/blob/main/docs/CUSTOMIZING.org][see here]]

#+begin_src emacs-lisp
  (use-package dirvish
    :ensure t
    :config
    (dirvish-override-dired-mode) ; Force the use of dirvish instead of dired
    (setq dirvish-attributes
          '(vc-state subtree-state all-the-icons file-time file-size))
    (setq dired-auto-revert-buffer t))

  ; TODO: Add a keybinding for inserting an empty file
#+end_src

I also don't really see the need for ~dired-toggle-read-only~, whereas I keep performing ~dired-create-empty-file~, thus I change the keybinding for this

#+begin_src emacs-lisp
(with-eval-after-load 'evil
  (with-eval-after-load 'dirvish
    (evil-define-key 'normal dirvish-mode-map (kbd "i") 'dired-create-empty-file)))
#+end_src

** ~undo-tree~
#+begin_src emacs-lisp
  (use-package undo-tree
    :ensure t
    :init
    ; (setq undo-tree-auto-save-history nil) ; Disable persistent history
    (global-undo-tree-mode 1))

  ; TODO: Make buffer width for calling undo-tree significantly thinner
#+end_src

** Global Keybindings and Vim
Setting this up at the top just in case

*** ~ESC~ Behaviors
**** Make ~ESC~ Instantly Responsive
- We want the ~ESC~ key to be immediately responsive
  - On default terminal Emacs, when the ~ESC~ key is pressed, there is about a 700ms delay between switching from insert mode to normal mode
    - This could be attributed to using a slower terminal emulator. The delay was quite big on WezTerm, but using Alacritty I noticed that this delay was significantly reduced
      - I tried using Emacs on Kitty, and it was the slowest. I've found that Alacritty in general is the best performing emulator
      - My laptop is also quite bad, so these performance differences are important

***** Evil
#+begin_src emacs-lisp
  (setq evil-esc-delay 0)
#+end_src

***** Emacs 27 and Before
#+begin_src emacs-lisp
  (setq escape-delay 0)
#+end_src

***** Emacs 28 and Later
#+begin_src emacs-lisp
  (setq key-escape-delay 0)
#+end_src

***** Terminal Emacs
#+begin_src emacs-lisp
  (setq tty-escape-code-delay 0)
#+end_src


**** Make ~ESC~ Key Quit Prompts
#+begin_src emacs-lisp
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit)  ; Make ESC quit prompts
#+end_src

This fixes the delay in WezTerm, although I'm not sure in the first place why the behavior is different across the two terminal emulators.

*** Evil Mode
Evil mode allows you to use Vim keybindings in all Emacs buffers. Vim keybindings are just better than Emacs keybindings

#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    (setq evil-want-integration t)
    (setq evil-want-keybinding nil)
    (setq evil-undo-system 'undo-tree)
    (setq evil-mode-line-format nil) ; disable evil state in modeline (using doom-modeline instead)
    :custom
    (evil-undo-system 'undo-tree)
    :config
    (evil-mode 1) ; turn on Evil mode
    ; (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state) ; I think this is the same as just hitting escape when you're not in insert mode
    ; (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)

    (evil-set-initial-state 'messages-buffer-mode 'normal)
    (evil-set-initial-state 'dashboard-mode 'normal)

    (define-key evil-normal-state-map (kbd "/") 'swiper)
    (define-key evil-visual-state-map (kbd "/") 'swiper))
#+end_src

**** Evil Collection
A package that extends Vim keybindings to work with other packages such as =magit=, =org=, =mu4e=, etc.
#+begin_src emacs-lisp
  (use-package evil-collection
    :after (evil magit)
    :ensure t
    :config
    (evil-collection-init))
#+end_src

** Indentation
Indentations will be described with the following syntax: ~n(s/t)~
- ~n~ refers to the indentation length. How many spaces the indentation appears (if it's a tab character, how long should the tab character appear)
- ~s~ refers to the indentation consisting of spaces (i.e. ~expandtab=on~)
- ~t~ refers to the indentation consisting of tab characters (i.e. ~expandtab=off~)

*** C++: ~4s~
#+begin_src emacs-lisp
  (setq auto-mode-alist
        (append
         '(("\\.cpp\\'" . c++-mode)
           ("\\.h\\'"   . c++-mode)
           ("\\.hpp\\'" . c++-mode)
           ("\\.cxx\\'" . c++-mode)
           ("\\.hxx\\'" . c++-mode)
           ("\\.cc\\'"  . c++-mode)
           ("\\.hh\\'"  . c++-mode))
         auto-mode-alist))

  ;; Set indentation settings for C++ mode
  (defun lv/c++-setup ()
    "Set up C++ indentation preferences."
    (setq c-basic-offset 4)      ; Set indentation to 4 spaces
    (setq tab-width 4)           ; Set tab width to 4
    (setq indent-tabs-mode nil)) ; Use spaces instead of tabs

  (add-hook 'c++-mode-hook 'lv/c++-setup)
#+end_src

*** Makefile: ~4t~
Makefile indentations [[https://www.gnu.org/software/make/manual/make.html#Recipe-Syntax][must be tabs]]. Spaces will not work.

#+begin_src emacs-lisp
  (defun lv/makefile-setup ()
    "Set up Makefile indenation preferences."
    (setq tab-width 4)         ; set tab width to 4
    (setq indent-tabs-mode t)) ; force tabs instead of spaces
  (add-hook 'makefile-mode-hook 'lv/makefile-setup)
#+end_src

*** Python: ~4s~
[[https://peps.python.org/pep-0008/#indentation][PEP-0008]] says 4 spaces per indentation level

#+begin_src emacs-lisp
  (defun lv/python-setup ()
    "Set up Python indentation preferences."
    (setq python-indent-offset 4) ; set indentation to 4 spaces
    (setq tab-width 4)
    (setq indent-tabs-mode nil) ; use spaces instead of tabs

    (add-hook 'python-mode-hook 'lv/python-setup))
#+end_src

*** TODO Languages to add
- sh: ~2s~

* Behaviors
** Remove Backup Files
Say that you're editing the file =foo.py=. Annoyingly, Emacs will create the file =foo.py~= as a backup file and will create =#foo.py#= if the file is currently being edited. We want to disable this.

#+begin_src emacs-lisp
  (setq make-backup-files nil)
  (setq auto-save-default nil)
#+end_src

** Require Final Newline
Every file should have a newline at the very end

#+begin_src emacs-lisp
  (setq mode-require-final-newline t)
#+end_src

** Use ~y~ and ~n~ for Prompts
I don't like needing to type the entire word ~yes~ or ~no~ and then pressing ~RET~ when prompted on things like if I want to save a file or not.

It's much easier to just use ~y~ and ~n~.

#+begin_src emacs-lisp
  (fset 'yes-or-no-p 'y-or-n-p)
#+end_src

** Alert for invalid action
When performing an action that can't be done (e.g. backspacing on first character of document, down arrow on last line, etc.):
- If ~t~, visual cue will show
- If ~nil~, bell will sound
- Default behavior is ~nil~

/NOTE/: On MacOS, this makes a large caution triangle which can be very annoying, so perhaps disable if using Mac

#+begin_src emacs-lisp
  (cond
   ((eq system-type 'gnu/linux)
    (setq visible-bell t))
   ((eq system-type 'darwin) ; MacOS
    (setq visible-bell nil)))
#+end_src

* Modules
** Ivy
Ivy is a completion framework that allows you to find files, switch buffers, etc.

#+begin_src emacs-lisp
  (use-package ivy
    :diminish
    :bind ((:map ivy-switch-buffer-map
             ("C-k" . ivy-previous-line)
             ("C-l" . ivy-done)
             ("C-d" . ivy-switch-buffer-kill))
           (:map ivy-reverse-i-search-map
             ("C-k" . ivy-previous-line)
             ("C-d" . ivy-reverse-i-search-kill)))
    :config
    (setq ivy-re-builders-alist
          '((t . ivy--regex-plus)))    ; Enable normal search globally
          ; '((t . ivy--regex-fuzzy))) ; Enable fuzzy search globally
                                       ; NOTE: These two options are mutually exclusive
    (ivy-mode 1))
#+end_src

*** Counsel
Counsel is an extension of Ivy and enhances features such as looking for commands, and makes use of Ivy's completion framework capabilities

#+begin_src emacs-lisp
    (use-package counsel
      :after ivy)
#+end_src

**** Ignoring Files in search
When searching for files using =M-x counsel-find-file=, you will get results for all existing files. Some files are incredibly annoying and I never have a need to find them. These are (listed with respect to the order on the regex expression):
- =.~undo-tree~=
  - Store file's undo-tree onto disk, used to load tree and undo across sessions
- =#foo#=
  - Emacs backup files
- =.DS_Store=
  - Used in MacOS to store custom attributes of the existing folder

Note that the syntax for regexes in Emacs is different than what you might be used to seeing in Perl.
- ~\\~ is used to begin a regex
- ~\\|~ is used to append regexes

[[https://regex101.com/][regex101]] is an excellent resource to build and test your regex strings.

#+begin_src emacs-lisp
  (setq counsel-find-file-ignore-regexp
        (concat "\\"
                ".~undo-tree~$\\|" ; .~undo-tree~
                ".*#.*#$"))        ; #foo#
#+end_src

** Helpful
Alternative help screen in Emacs that gives better information on possible values for variables and functions, as well as default values

#+begin_src emacs-lisp
  (use-package helpful
    :ensure t
    :custom
    (counsel-describe-function-function #'helpful-callable)
    (counsel-describe-variable-function #'helpful-variable)
    :bind
    ([remap describe-function] . counsel-describe-function)
    ([remap describe-command] . helpful-command)
    ([remap describe-variable] . counsel-describe-variable)
    ([remap describe-key] . helpful-key))
#+end_src

** SQLite3
This is depended by =magit=. Please install the necessary system modules beforehand (check Pre-requisites for more information)

#+begin_src emacs-lisp
  (use-package sqlite3
    :ensure t)
#+end_src

** Git
*** Magit
Magit is a porcerlain for Git that allows you to quickly stage, commit, pull, push, and do other basic Git commands with just a series of keybindings. It is a great way to quickly perform actions and not need to open a shell to perform Git commands.

#+begin_src emacs-lisp
  ;; Git porcelain
  (use-package magit
    :commands (magit-status magit-get-current-branch) ; lazy load
    :custom
    (magit-display-buffer-function #'magit-display-buffer-same-window-except-diff-v1))
#+end_src

**** Tweaks
***** Insert Mode in Commit Message Prompts
When writing a commit mesasge, I want to be in /insert mode/ immediately

#+begin_src emacs-lisp
  (add-hook 'with-editor-mode-hook 'evil-insert-state)
#+end_src

***** Stop ~ediff~ from Creating New Window just for Help Commands
Very annoyingly, ~ediff~ will create a new window just for showing you help commands upon being invoked. This totally messes up my workflow especially if Emacs is full-screened.

We want to disable this.

#+begin_src emacs-lisp
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

***** Show ~ediff~ Diffs Vertically
The default behavior is that diffs are split horizontally (-). I prefer vertical splits (|) when viewing diffs as that's probably just what I've been used to with GitHub's UI.

I have no idea why, but the following will change the behavior to have vertical splits.

#+begin_src emacs-lisp
  (setq ediff-split-window-function 'split-window-horizontally)
#+end_src

***** Add Better Visibility to ~ediff~ Diffs
This will add a faint background to lines with merge-conflicting diffs

#+begin_src emacs-lisp
  (custom-set-faces
   '(ediff-current-diff-A ((t (:background "yellow" :foreground "black"))))
   '(ediff-current-diff-B ((t (:background "yellow" :foreground "black"))))
   '(ediff-fine-diff-A ((t (:background "orange" :foreground "black"))))
   '(ediff-fine-diff-B ((t (:background "orange" :foreground "black")))))
#+end_src

***** Refine Differences in ~ediff~
Narrow down the exact words or characters that differ

#+begin_src emacs-lisp
  (setq ediff-auto-refine 'on)
#+end_src

***** Use ~:w~ and ~:q~ to commit/abort
While I am used to doing =C-c C-c= to commit a message at this point, I want to do it the Vim way

#+begin_src emacs-lisp
  (defun lv/magit-commit-save-and-exit ()
    "Commit the message and close the buffer."
    (interactive)
    (with-editor-finish))

  (defun lv/magit-commit-abort ()
    "Abort the commit message and close the buffer."
    (interactive)
    (with-editor-cancel))

  (defun lv/setup-git-commit-mode-evil-commands ()
    "Set up buffer-local Evil ex commands in `git-commit-mode`."
    ;; Make `evil-ex-commands` buffer-local by copying it as a hash table
    (setq-local evil-ex-commands (copy-hash-table evil-ex-commands))
    ;; Define buffer-local ex commands
    (evil-ex-define-cmd "w[rite]" #'lv/magit-commit-save-and-exit) ; FIXME: Fix this, performing just ~:w~ doesn't commit and then quit buffer
    (evil-ex-define-cmd "wq"     #'lv/magit-commit-save-and-exit)
    (evil-ex-define-cmd "q[uit]" #'lv/magit-commit-abort))

  ;; Add the hook for `git-commit-mode`
  (add-hook 'git-commit-mode-hook #'lv/setup-git-commit-mode-evil-commands)
#+end_src

***** Change Text Color for Highlighted Added Diffs
- On Alacritty for some reason, added diffs (highlighted in green) are really hard to see with the default settings (green text on green background)
  - This behavior is different when using WezTerm
    - Regardless, I will change this for all non-grahical instances of Emacs

#+begin_src emacs-lisp
  (unless (display-graphic-p)
    (with-eval-after-load 'magit
      (set-face-attribute 'magit-diff-added nil
                          :foreground "#003000"
                          :background nil)
      (set-face-attribute 'magit-diff-added-highlight nil
                          :foreground "#003000"
                          :background nil)))
#+end_src

*** Forge
Forge is an extension of ~magit~ that adds support for interacting with Git forges such as GitHub, directly from Emacs.

You can view, comment, and create pull requests or issues directly from Emacs.

#+begin_src emacs-lisp
  (use-package forge)
#+end_src

*** TODO
- [ ] Make ~<escape>~ key abort (give it the same behavior as ~C-g~) in =magit=

** Swiper
Swiper is used to search within the current buffer

With the default behavior, pressing =n= goes to the previous word whereas =C-n= goes to the next word. In Vim, it's =n= to go next and =Shift n= to go before

#+begin_src emacs-lisp
  (use-package swiper
    :after ivy
    :config
    ;; Rebind Evil keys for navigating matches after Swiper
    (evil-define-key 'normal 'global
      (kbd "n") 'isearch-repeat-forward
      (kbd "N") 'isearch-repeat-backward))
#+end_src

** ~hl-todo~
Highlight TODOs, FIXMEs, NOTEs, etc.

#+begin_src emacs-lisp
  (use-package hl-todo
    :hook (prog-mode . hl-todo-mode)
    :config
    (setq hl-todo-keyword-faces
          '(("TODO"   . "#FFFF00")
            ("FIXME"  . "#FF0000")
            ("DEBUG"  . "#00FFFF")
            ("NOTE"   . "#50C878")
            ("GOTCHA" . "#A020F0")
            ("HACK"   . "#FFA500")
            ("STUB"   . "#7393B3"))))
#+end_src

** ~which-key~
which-key shows which keybindings to press to invoke a command if such a keybinding exists

#+begin_src emacs-lisp
  (use-package which-key
    :init (which-key-mode)
    :diminish which-key-mode
    :config
    (setq which-key-idle-delay 0.3)) ; seconds
#+end_src

** Slime
Slime is an IDE for Lisp

#+begin_src emacs-lisp
  (use-package slime
    :ensure t
    :config
    (setq inferior-lisp-program "sbcl")
    (slime-setup '(slime-fancy)))
#+end_src

#+begin_src emacs-lisp
  (use-package paredit
    :ensure t
    :hook (emacs-lisp-mode lisp-mode))
#+end_src

* LSP
Main documentation can be found [[https://emacs-lsp.github.io/lsp-mode/][here]].

** Add-ons
*** Header Breadcrumb
We add a breadcrumb to show the relative path of our current buffer in regards to the rest of the project

#+begin_src emacs-lisp
  (defun lv/lsp-setup-mode ()
    (setq lsp-headerline-breadcrumb-segments '(path-up-to-project file symbols))
    (setq lsp-headerline-breadcrumb-enable t)
    (setq lsp-headerline-breadcrumb-icons-enable t))

  ; TODO: Fix the missing icons in this breadcrumb header
#+end_src

** Installation
Install and use ~lsp-mode~

#+begin_src emacs-lisp
  (use-package lsp-mode
    :ensure t
    :commands (lsp lsp-deferred)
    :hook ((lsp-mode    . lv/lsp-setup-mode)
           (c++-mode    . lsp-deferred)
           (c-mode      . lsp-deferred)
           (python-mode . lsp-deferred)
           (yaml-mode   . lsp-deferred))
    :init
    (setq lsp-keymap-prefix "C-c l")
    :config
    (lsp-enable-which-key-integration t)
    :custom
    (lsp-idle-delay 0.5)
    (lsp-log-io nil)
    (gc-cons-threshold 100000000)
    (read-process-output-max (* 1024 1024)))
#+end_src

** Extra Packages
*** Debugger
#+begin_src emacs-lisp
  (use-package dap-mode)
  ;; (use-package dap-LANGUAGE) to load the dap adapter for your language
#+end_src

*** ~which-key~ Integration
#+begin_src emacs-lisp
  (use-package which-key
    :config
    (which-key-mode))
#+end_src

*** ~flycheck~
Performs real-time syntax checking
#+begin_src emacs-lisp
  (use-package flycheck
    :ensure t
    :init (global-flycheck-mode))

  ; TODO: Make sure that =RET= doesn't result in autocompletion and instead creates a newline. Use =TAB= to autocomplete instead
#+end_src

*** ~lsp-treemacs~
#+begin_src emacs-lisp
  (use-package lsp-treemacs
    :after (lsp-mode treemacs)
    :commands lsp-treemacs-errors-list) ; only load when this command is called
#+end_src

** Languages
*** TODO Docker
Add LSP integration with Docker. Use the following resources:
- [[https://github.com/emacs-lsp/lsp-docker][LSP Docker]]
- [[https://happihacking.com/blog/posts/2023/dev-containers-emacs/][Docker Dev Containers in Emacs]] (like in VSCode)

*** Nix (Nil)
[[https://emacs-lsp.github.io/lsp-mode/page/lsp-nix-nil/][lsp-mode Nix Nil documentation]]

- I almost exclusively edit Nix packages when I'm using NixOS`
  - The package is called /nil/ on nixpkgs ([[https://search.nixos.org/packages?channel=24.05&show=nil&from=0&size=50&sort=relevance&type=packages&query=nil][link]])

#+begin_src emacs-lisp
  (use-package lsp-nix
    :ensure lsp-mode
    :after (lsp-mode)
    :demand t
    :custom
    (lsp-nix-nil-formatter ["nixfmt"]))

  (use-package nix-mode
    :hook (nix-mode . lsp-deferred)
    :ensure t)
#+end_src

*** Python (basedpyright)
[[https://emacs-lsp.github.io/lsp-pyright/][lsp-mode Pyright documentation]]

Firstly, you will need to install ~basedpyright~ (and ~ruff~ for some reason) manually

#+begin_src sh :tangle no
  pip install basedpyright
  pip install ruff
#+end_src

And then we can install and use ~lsp-pyright~

#+begin_src emacs-lisp
  (use-package lsp-pyright
    :ensure t
    :custom (lsp-pyright-langserver-command "basedpyright")
    :hook (python-mode . (lambda ()
                           (require 'lsp-pyright)
                           (lsp-deferred))))
#+end_src

*** YAML

#+begin_src emacs-lisp
  (use-package yaml-mode
    :ensure t
    :mode "\\.ya?ml\\'"
    :hook (yaml-mode . lsp-deferred))
#+end_src

** Company Mode
- Before, we'd need to invoke ~M-x completion-at-point~ everytime to get the buffer of autocompletable things
  - We get this automatically with ~company-mode~

- I like autocompleting by pressing ~TAB~ (the default behavior is pressing ~ENTER~)
  - Even if you rebind this to ~TAB~, the default behavior remains
    - I've binding ~ENTER~ to ~newline~ to fix this

- ~TAB~ key in GUI != ~TAB~ key in Terminal Emacs
  - In GUI, ~TAB~ is ~<tab>~
  - In Terminal mode, ~TAB~ is ~C-i~

#+begin_src emacs-lisp
  (use-package company
    :after lsp-mode
    :hook (prog-mode . company-mode)
    :bind
    (:map company-active-map
          ("<tab>"    . company-complete-selection)
          ("C-i"      . company-complete-selection)
          ("<return>" . newline))
    (:map lsp-mode-map
          ("<tab>"    . company-indent-or-complete-common)
          ("C-i"      . company-indent-or-complete-common)
          ("<return>" . newline))
    :custom
    (company-minimum-prefix-length 1)
    (company-idle-delay 0.0)) ; seconds
#+end_src

#+begin_src emacs-lisp
  (use-package company-box
    :hook (company-mode . company-box-mode))
#+end_src

** LSP UI
Additional UI integrations.

See the [[https://github.com/emacs-lsp/lsp-ui][GitHub repo]] for more info.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :hook (lsp-mode . lsp-ui-mode))
#+end_src

** Ivy

#+begin_src emacs-lisp
  (use-package lsp-ivy
    :commands lsp-ivy-workspace-symbol)
#+end_src

* Keybindings
** Leader Key
I like to use keybindings by pressing a leader key, which I map as the spacebar.

#+begin_src emacs-lisp
  ;; Setup keybindings with a leader key
  (use-package general
    :ensure t
    :config
    (general-evil-setup t)

    (general-create-definer lv/leader-keys
      :states '(normal visual)
      :keymaps 'override
      :prefix "SPC"
      :global-prefix "C-SPC"))
#+end_src

** =M-x=
The Meta key (=M-x=) is used to evaluate commands.

#+begin_src emacs-lisp
  (lv/leader-keys
    ":" '(counsel-M-x :which-key "M-x"))
#+end_src

** =DEL=
I use the =DEL= key to return to the previous buffer. I know that this should be in window, but I use it too often to do ~wbb~ every time I want to go to the previous buffer.
#+begin_src emacs-lisp
  (lv/leader-keys
    "DEL" '(evil-switch-to-windows-last-buffer :which-key "go to prev context"))
#+end_src

** Code
When I open ~flymake-show-buffer-diagnostics~, I want the cursor to move to the new buffer. Otherwise, I need to move the cursor to this new buffer and then press ~q~ to close it.

#+begin_src emacs-lisp
  (defun lv/flymake-show-buffer-diagnostics-and-focus ()
    (interactive)
    (flymake-show-buffer-diagnostics)
    (other-window 1))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "c"   '(:ignore c                                    :which-key "code")
    "cd"  '(lsp-find-declarations                        :which-key "declaration")
    "cD"  '(lsp-find-definition                          :which-key "definition")
    "cf"  '(lsp-format-buffer                            :which-key "format")
    "cg"  '(lv/flymake-show-buffer-diagnostics-and-focus :which-key "diagnostics")
    "ci"  '(lsp-find-implementation                      :which-key "implementation")
    "cr"  '(lsp-find-references                          :which-key "references")
    "ct"  '(:ignore ct                                   :which-key "treemacs")
    "ctr" '(lsp-treemacs-references                      :which-key "references")
    "cts" '(lsp-treemacs-symbols                         :which-key "symbols")
    "ctt" '(treemacs                                     :which-key "tree")
    "cT"  '(lsp-find-type-definition                     :which-key "type definition"))

  ; TODO: Make buffers smaller for references, definitions, etc. Don't let it take 50% of the screen.
#+end_src

** Evaluate
#+begin_src emacs-lisp
  (lv/leader-keys
    "e"  '(:ignore e       :which-key "evaulate")
    "eb" '(eval-buffer     :which-key "buffer")
    "ee" '(eval-expression :which-key "expression"))
#+end_src

** File
I want a keybinding dedicated exclusively to opening specific files/directories

#+begin_src emacs-lisp
  (defun lv/open-config-file ()
    (interactive)
    (find-file (concat user-emacs-directory "src/main.org")))
#+end_src

#+begin_src emacs-lisp
  (defun lv/open-org-dir ()
    (interactive)
    (find-file lv/org-directory))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "f"  '(:ignore f           :which-key "file")
    "ff" '(counsel-find-file   :which-key "find")
    "fc" '(lv/open-config-file :which-key "open config")
    "fg" '(counsel-rg          :which-key "ripgrep")
    "fo" '(lv/open-org-dir     :which-key "open org"))

  ; TODO: Add functionality where going through the different options gives you a preview of the code in the other window
#+end_src

** Git
#+begin_src emacs-lisp
  (lv/leader-keys
    "g"  '(:ignore g    :which-key "git")
    "gg" '(magit-status :which-key "status"))
#+end_src

** Help
#+begin_src emacs-lisp
  (lv/leader-keys
    "h"  '(:ignore h                 :which-key "help")
    "hf" '(counsel-describe-function :which-key "function")
    "hk" '(describe-key              :which-key "key")
    "hv" '(counsel-describe-variable :which-key "variable"))
#+end_src

** Slime
#+begin_src emacs-lisp
  (lv/leader-keys
    "s"  '(:ignore s                   :which-key "slime")
    "sc" '(slime-compile-and-load-file :which-key "compile and load")
    "ss" '(slime                       :which-key "start slime")
    )
#+end_src


** Undo-tree
#+begin_src emacs-lisp
  (lv/leader-keys
    "u" '(undo-tree-visualize :which-key "undo tree"))

  ; TODO: Make buffer less wide. Doesn't need to take half of the screen
#+end_src

** Window
The following is a helper function for toggling full screen on and off

As per [[https://emacs.stackexchange.com/a/9725][Stack Exchange]]:

#+begin_src emacs-lisp
  (defun lv/fullscreen ()
    (interactive)
    (set-frame-parameter nil 'fullscreen 'fullboth))

  (defun lv/non-fullscreen ()
    (interactive)
    (set-frame-parameter nil 'width 82)
    (set-frame-parameter nil 'fullscreen 'fullheight))

  (defun toggle-fullscreen ()
    (interactive)
    (if (eq (frame-parameter nil 'fullscreen) 'fullboth)  ;tests if already fullscreened
        (lv/non-fullscreen)
      (lv/fullscreen)))
#+end_src

#+begin_src emacs-lisp
  (lv/leader-keys
    "w"   '(:ignore w              :which-key "window")
    "wb"  '(:ignore wb             :which-key "buffer")
    "wbk" '(kill-buffer-and-window :which-key "kill")
    "wbl" '(list-buffers           :which-key "list")
    "wbs" '(counsel-switch-buffer  :which-key "switch")
    "wf"  '(toggle-fullscreen      :which-key "toggle fullscreen")
    "wh"  '(evil-window-left       :which-key "move left")
    "wj"  '(evil-window-down       :which-key "move down")
    "wk"  '(evil-window-up         :which-key "move up")
    "wl"  '(evil-window-right      :which-key "move right")
    "wm"  '(maximize-window        :which-key "maximize window")
    "ws"  '(evil-window-split      :which-key "split horizontally")
    "wt"  '(tab-bar-new-tab        :which-key "new tab")
    "wv"  '(evil-window-vsplit     :which-key "split vertically"))
#+end_src

* TODO Future Features to add
- Maybe add workspaces (on top of tabs)
- Split config into multiple files
- Replicate /oil.nvim/
- Migrate away from /lsp-mode/ to something like /lsp-bridge/

* TODO Non-obvious things to fix
- Pressing the tab character in terminal emacs does not result in an indent behavior
  - This should happen if there's no autocomplete box to fill
  - This behavior does not happen in Makefile
  - This happens in Python, Org-mode

* Load Config Modules
This configuration is modularized for maintainability.

#+begin_src emacs-lisp
  (defun lv/org-babel-load-file (file-path)
    "Load an org-babel file from the root emacs config directory."
    (org-babel-load-file
     (expand-file-name
      (concat user-emacs-directory file-path))))
#+end_src

#+begin_src emacs-lisp
  (lv/org-babel-load-file "src/modules/eshell.org")
  (lv/org-babel-load-file "src/modules/org.org")
  (lv/org-babel-load-file "src/modules/projectile.org")
#+end_src
